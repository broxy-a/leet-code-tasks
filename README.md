# 🧠 LeetCode Java задачи с пояснениями.

Тут будет хранится разбор задач с сайта [LeetCode](https://leetcode.com/). Все задачи выполнены на языке Java. Каждая задача сопровождается примером и ключевыми моментами.

---

## ➕ TwoSum

Нужно найти индексы двух чисел в массиве, которые в сумме дают target.

```java
int[] nums = {2, 7, 11, 15}; int target = 9; -> [0, 1].

🔹 Основные моменты:
    📌 Первый цикл перебирает массив nums.
    📌 Второй цикл ищет вторую часть пары nums[j].
    📌 Подойдетдля маленьких массивов (n < 100) или когда важна простота кода.

## ◀️ Palindrome Number

Дано целое число x. Нужно определить, является ли оно палиндромом.

int x = 1221; -> true  
int x = -121; -> false

🔹 Основные моменты:
    📌 Сначала отбрасываются отрицательные числа и числа, оканчивающиеся на 0 (исключение — 0).
    📌 Переворачивается только половина числа, чтобы избежать переполнения и лишних вычислений.
    📌 Сравниваются оригинал и перевёрнутая половина.

## 🔄 Valid Parentheses

Дана строка s, содержащая только символы '(', ')', '{', '}', '[' и ']'. Необходимо определить, является ли строка валидной.

(validator.isValid("()")); -> true
(validator.isValid("()[]{}")); -> true
(validator.isValid("(]")); -> false
(validator.isValid("([)]")); -> false

🔹 Основные моменты:
    📌 Используется стек (LIFO - Last In First Out) для отслежевания скобок. 
    📌 Проходит по строке циклом for.
    📌 Обрабатывает случаи с открытыми скобками.
    📌 Обрабатывает случаи с закрытыми скобками.

## ♻️ Merge Two Sorted Lists

Даны два отсортированных связанных списка, нужно объединить их в один. Новый список должен состоять из связанных узлов исходных списков и список должен быть отсортирован по возрастанию.

list1[1, 2, 4]
list2[1, 3, 4]
mergeList[1, 1, 2, 3, 4, 4] 

🔹 Основные моменты:
    📌 Создается фиктивный узел dummy который служит заглушкой, чтобы не обрабатывать пустой список.
    📌 Указатель current который проходит по этому узлу.
    📌 В цикле на каждой итерации выбирается меньший элемент из двух списков (list1 и list2).
    📌 Если один список закончился раньше, оставшиеся узлы автоматически добавляются в результат.

## ❌ Remove Duplicates From Sorted Array

Дан массив, нужно удалить дубликаты в отсортированном массиве, сохранив порядок элементов.

nums[1, 1, 2] -> nums[1, 2]
nums[0, 0, 1, 1, 1, 2, 2, 3, 3, 4] -> nums[0, 1, 2, 3, 4]

🔹 Основные моменты:
    📌 Создается указатель который хранит последний уникальный элемент. Unique = 0; - т.к первый элемент всегда уникален.
    📌 Проверка на пустой массив. if (nums.length == 0);
    📌 Цикл который проходит по массиву начиная со второго числа. int i = 1;
    📌 На каждой итерации при нахождении уникального элемента if (nums[i] != nums[Unique]): сдвигаем Unique++ и записываем nums[i] в новую позицию.

## ❌ Remove Element

Дан массив, нужно перезаписать его, исключая заданное число val. Задача похожа на Remove Duplicates.

nums[3,2,2,3] -> nums[2,2]

🔹 Основные моменты:
    📌 Создается указатель, в котором содержится подходящий элемент
    📌 Проходим по всему массиву
    📌 На каждой итерации, проверяем если число с индексом i не равно val, то мы его записываем в на позицию current, а сам current двигаем далее.

## 📏 Length of last word

В этой задаче надо найти длинну последнего слова в массиве.

[Hello World] -> 5
[Artorias Abysswalker] -> 11

🔹 Основные моменты:
    📌 Создается массив где строка разделяется пробелами
    📌 Возвращается последний элемент массива

## 🔍 Search insert position

Задача требует воспользоваться бинарным поиском для числа target. Вернуть индекс target, если он найден, если нет указать его место для вставки.

🔹 Основные моменты:
    📌 Массив отсортирован, т.к бинарный поиск работает только с такими
    📌 Если target меньше чем mid, то двигаемся в левую часть массива
    📌 Если иначе, то идем в право
    📌 Вернем low, т.к если элемент не найдент то low указывает то куда нужно вставить target

## ➕ Plus One

Дано ццелое число в виде массива, каждый элемент в нем это цифра, расположенная от старшей к младшей. 1,2,4 -> 1 - сотни, 2 - десятки, 4 - единицы.

[1,2,3] -> [1,2,4]
[4,3,2,1] -> [4,3,2,2]
[9,9,9] -> [1,0,0,0]

🔹 Основные моменты:
    📌 Цикл идет с конца, т.к это обычная процедура сложения столбиком
    📌 Если элемент массива меньше 9, то прибавляем 1 и заканчиваем
    📌 Если элемент равен 9, значит превращаем его в 0
    📌 В случае с 9, создается новый массив который по длинне больше чем исходный на 1. 

## √ SqrtX

Эта задача требует написать алгоритм который вычисляет корень числа (вернее будет сказать угадывает)

SqrtX(26) -> 5
SqrtX(191) -> 13
SqrtX(26) -> 1

🔹 Основные моменты:
    📌 Используется бинарный поиск для решения. Сложность O(log x).
    📌 При нахождении числа с плавающей точкой, выводит ближайшее целое
    📌 Возвращает наибольшее число чей квадрат меньше или равен x

## 🪜 Climbing Stairts

В этой задаче нужно написать функцию которая будет считать количество способов которыми можно подняться по лестнице из n ступенек, если за один раз можно подяться на 1 или 2 ступеньки.

n = 2 -> result = 2;
n = 1 -> result = 1;
n = 30 -> result = 1346269;

🔹 Основные моменты:
    📌 Создается массив для хранения все возможных комбинаций
    📌 Базовые случаи сразу обозначены
    📌 Цикл начинает идти если n = 3 и более, и считает все по формуле
    📌 Используется рекуррентное соотношение (схоже с числами Фибонначи) f(n)=f(n−1)+f(n−2).

♻️ Remove duplibcates from sorted list

Эта задача требует удалить дубликаты из отсортированного связанного списка.

[3,3,4,4,5,5,5] -> [3,4,5,]
[1,1,2,2,3,3] -> [1,2,3]

🔹 Основные моменты:
    📌 Используется указатель current который двигается по списку
    📌 Временная сложность у решения O(n), n - количество узлов
    📌 Если значение текущего элемента равно значению следующего элемента, то двигаем указатель и удаляем дубликат.
    📌 Если они не равны то просто двигаем указатель.

94. Binary Tree Inorder Traversal

В этой задаче требуется пройти по бинарному деревусделать это надо с помощью метода inorder traversal — то есть пройтись по каждому узлу дерева в порядке:левый — корень — правый.

    1
     \
      2 -> result[1,3,2];
     /
    3

🔹 Основные моменты:
    📌 Решение написано с помощью рекурсии.
    📌 Рекурсивная функция сначала проходидт левое поддерево, затем правое.
    📌 Между этими "обходами" результаты записываются в список.
    📌 Слонжость O(n), т.к мы проходим по каждому узлу лишь один раз.
